"""
Genesis Build Executor + Governance Registration
────────────────────────────────────────────────
Builds agent scaffolds from queued payloads, verifies outputs,
registers them in the governance ledger, and generates Junie handoff tasks.
"""

from __future__ import annotations
import json
import os
import time
import subprocess
from datetime import datetime, timezone
from pathlib import Path

# ────────── CONFIGURATION ──────────
PROJECT_ROOT = Path(__file__).resolve().parents[1]
LOGS_DIR = PROJECT_ROOT / "logs"
AGENTS_DIR = PROJECT_ROOT / "factory_agents"
BUILD_LOG = LOGS_DIR / "genesis_build_requests.jsonl"
SESSION_LOG = LOGS_DIR / f"genesis_session_{datetime.now(timezone.utc).date()}.log"
LEDGER_LOG = LOGS_DIR / "governance_ledger.jsonl"
CHECK_INTERVAL = 5  # seconds


# ────────── HELPERS ──────────
def timestamp() -> str:
    return datetime.now(timezone.utc).isoformat()


def log_event(msg: str):
    """Log to console and file."""
    LOGS_DIR.mkdir(parents=True, exist_ok=True)
    formatted = f"[{timestamp()}] [GenesisExecutor] {msg}"
    print(formatted)
    with open(SESSION_LOG, "a", encoding="utf-8") as f:
        f.write(formatted + "\n")


def append_ledger(entry: dict):
    LEDGER_LOG.parent.mkdir(parents=True, exist_ok=True)
    with open(LEDGER_LOG, "a", encoding="utf-8") as f:
        f.write(json.dumps(entry, ensure_ascii=False) + "\n")


def load_processed_ids() -> set[str]:
    cache = LOGS_DIR / "executor_processed.json"
    if cache.exists():
        try:
            return set(json.loads(cache.read_text()))
        except Exception:
            return set()
    return set()


def save_processed_ids(ids: set[str]):
    (LOGS_DIR / "executor_processed.json").write_text(json.dumps(list(ids), indent=2))


# ────────── BUILD + VERIFY ──────────
def generate_agent(payload: dict) -> Path:
    """Generate minimal scaffold for new agent."""
    name = payload.get("agent_name", "unknown").lower().replace(" ", "_")
    codename = payload.get("codename", name.title())
    purpose = payload.get("purpose", "")
    agent_path = AGENTS_DIR / name
    agent_path.mkdir(parents=True, exist_ok=True)

    # Persona and entrypoint
    (agent_path / f"persona_{name}.yaml").write_text(
        f"name: {codename}\npurpose: {purpose}\n", encoding="utf-8"
    )
    (agent_path / "main.py").write_text(
        f'"""Autogenerated agent {codename} ({name})"""\n\n'
        f"def run():\n"
        f"    print('Hello from {codename}!')\n",
        encoding="utf-8",
    )
    (agent_path / "requirements.txt").write_text(
        "\n".join(payload.get("dependencies", [])), encoding="utf-8"
    )

    log_event(f"Generated agent scaffold for {codename} at {agent_path}")
    return agent_path


def verify_agent(agent_path: Path) -> dict:
    """Ensure core files exist and are non-empty."""
    expected = ["main.py", "requirements.txt"]
    existing = {p.name for p in agent_path.glob("*")}
    missing = [f for f in expected if f not in existing]
    empties = [f for f in expected if (agent_path / f).stat().st_size == 0]
    ok = not missing and not empties
    return {"ok": ok, "missing": missing, "empty": empties}


def runtime_selfcheck(agent_path: Path) -> dict:
    """Run the agent’s main file in a subprocess and capture output."""
    main_file = agent_path / "main.py"
    if not main_file.exists():
        return {"ok": False, "error": "main.py missing"}

    try:
        result = subprocess.run(
            ["python", str(main_file)],
            capture_output=True,
            text=True,
            timeout=10
        )
        ok = result.returncode == 0
        return {
            "ok": ok,
            "stdout": result.stdout.strip(),
            "stderr": result.stderr.strip(),
            "exit_code": result.returncode
        }
    except subprocess.TimeoutExpired:
        return {"ok": False, "error": "Timed out during runtime check"}
    except Exception as e:
        return {"ok": False, "error": str(e)}


def register_in_governance(payload: dict, agent_path: Path, verification: dict, runtime: dict):
    """Append verified agent entry to governance ledger."""
    entry = {
        "timestamp": timestamp(),
        "agent_name": payload.get("agent_name"),
        "codename": payload.get("codename"),
        "path": str(agent_path),
        "verification": verification,
        "runtime_check": runtime,
        "registered_by": "GenesisExecutor",
    }
    append_ledger(entry)
    log_event(f"Registered {payload.get('agent_name')} in governance ledger.")


# ────────── JUNIE TASK GENERATOR ──────────
def generate_junie_task(payload: dict):
    """Auto-generate a Junie handoff task after Genesis build."""
    task_dir = PROJECT_ROOT / "junie_tasks"
    task_dir.mkdir(parents=True, exist_ok=True)

    task_file = task_dir / f"{payload.get('agent_name', 'unknown').lower()}_extension_task.json"
    content = {
        "task_id": f"extend_{payload.get('agent_name', 'unknown').lower()}",
        "issued_by": "GenesisExecutor",
        "target_agent": payload.get("agent_name"),
        "timestamp": timestamp(),
        "objective": f"Extend {payload.get('agent_name')} with doctrinal and research integration capabilities.",
        "steps": [
            {"step": 1, "action": "Generate and implement missing integration modules."},
            {"step": 2, "action": "Link governance doctrine and global research APIs."},
            {"step": 3, "action": "Deploy and validate FastAPI service endpoints."},
            {"step": 4, "action": "Register updated agent in governance ledger."}
        ],
        "handoff": {"next_actor": "Junie", "mode": "manual_or_automated"}
    }

    task_file.write_text(json.dumps(content, indent=2))
    log_event(f"Generated Junie task handoff file: {task_file}")


# ────────── MAIN LOOP ──────────
def process_new_requests():
    processed = load_processed_ids()
    if not BUILD_LOG.exists():
        return

    with open(BUILD_LOG, "r", encoding="utf-8") as f:
        for i, line in enumerate(f):
            if not line.strip() or str(i) in processed:
                continue
            try:
                entry = json.loads(line)
                payload = entry.get("payload", {})
                name = payload.get("agent_name", "Unknown")
                log_event(f"Processing build_agent request #{i} ({name})")

                agent_path = generate_agent(payload)
                verify = verify_agent(agent_path)
                runtime = runtime_selfcheck(agent_path)

                if verify["ok"]:
                    log_event(f"Runtime self-check for {name}: {'OK' if runtime['ok'] else 'FAILED'}")
                    register_in_governance(payload, agent_path, verify, runtime)
                    generate_junie_task(payload)
                else:
                    log_event(f"Verification failed for {name}: {verify}")

                processed.add(str(i))

            except json.JSONDecodeError:
                log_event(f"[WARN] Skipped malformed JSON line #{i}")
            except Exception as e:
                log_event(f"[ERROR] Exception while processing #{i}: {e}")

    save_processed_ids(processed)


def main():
    log_event("Genesis Build Executor started — watching for new payloads.")
    while True:
        process_new_requests()
        time.sleep(CHECK_INTERVAL)


if __name__ == "__main__":
    main()


